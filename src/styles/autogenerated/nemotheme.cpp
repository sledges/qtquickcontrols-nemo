/*
 * Copyright (C) 2013 Lucien Xu <sfietkonstantin@free.fr>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Library General Public License for more details.
 *
 * You should have received a copy of the GNU Library General Public License
 * along with this library; see the file COPYING.LIB.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 * Boston, MA 02110-1301, USA.
 */

// This class is autogenerated using themehelper.py
// Any modification done in this file will be overridden

#include "nemotheme.h"
#include <QtCore/QDebug>
#include <QtCore/QDir>
#include <QtCore/QFile>
#include <QtCore/QJsonDocument>
#include <QtCore/QJsonArray>
#include <QtCore/QJsonObject>
#include <QtCore/QJsonValue>
#include <QtGui/QFontDatabase>

static const char *GLACIER_THEME = "glacier.json";
static const char *THEME_NAME_KEY = "name";
static const char *THEME_DESCRIPTION_KEY = "description";
static const char *THEME_DEFINES_KEY = "defines";
static const char *THEME_STYLES_KEY = "styles";

NemoTheme::NemoTheme(QObject *parent)
    : QObject(parent)
    , m_button(new NemoThemeButton(this))
    , m_primaryButton(new NemoThemeButton(this))
    , m_groove(new NemoThemeGroove(this))
    , m_textField(new NemoThemeTextField(this))
    , m_toolBar(new NemoThemeToolBar(this))
    , m_window(new NemoThemeWindow(this))
    , m_page(new NemoThemePage(this))
    , m_spinner(new NemoThemeSpinner(this))
    , m_label(new NemoThemeLabel(this))
    , m_checkbox(new NemoThemeCheckbox(this))
{
    loadFromFile(GLACIER_THEME);
    int id = QFontDatabase::addApplicationFont("/usr/share/fonts/google-opensans/OpenSans-Regular.ttf");
    QStringList families = QFontDatabase::applicationFontFamilies(id);
    if (families.isEmpty()) {
        qWarning() << "W" << "Failed to load font" << QString("/usr/share/fonts/google-opensans/OpenSans-Regular.ttf");
        return;
    }
    m_fontFamily = families.first();
}

QString NemoTheme::name() const
{
    return m_name;
}

void NemoTheme::setName(const QString &name)
{
    if (m_name != name) {
        m_name = name;
        emit nameChanged();
    }
}

QString NemoTheme::description() const
{
    return m_description;
}

void NemoTheme::setDescription(const QString &description)
{
    if (m_description != description) {
        m_description = description;
        emit descriptionChanged();
    }
}

NemoThemeButton * NemoTheme::button() const
{
    return m_button;
}

NemoThemeButton * NemoTheme::primaryButton() const
{
    return m_primaryButton;
}

NemoThemeGroove * NemoTheme::groove() const
{
    return m_groove;
}

NemoThemeTextField * NemoTheme::textField() const
{
    return m_textField;
}

NemoThemeToolBar * NemoTheme::toolBar() const
{
    return m_toolBar;
}

NemoThemeWindow * NemoTheme::window() const
{
    return m_window;
}

NemoThemePage * NemoTheme::page() const
{
    return m_page;
}

NemoThemeSpinner * NemoTheme::spinner() const
{
    return m_spinner;
}

NemoThemeLabel * NemoTheme::label() const
{
    return m_label;
}

NemoThemeCheckbox * NemoTheme::checkbox() const
{
    return m_checkbox;
}

QString NemoTheme::fontFamily() const
{
    return m_fontFamily;
}

static inline QJsonValue jsonValue(const QJsonObject &object, const QString &key,
                                   const QString &objectName = QString())
{
    if (!object.contains(key)) {
        if (objectName.isEmpty()) {
            qWarning() << "W" << "Root JSON object does not have value" << key;
        } else {
            qWarning() << "W" << "JSON Object" << objectName << "does not have value" << key;
        }
        return QJsonValue();
    }
    
    return object.value(key);
}
    
static inline QString jsonToString(const QJsonValue &value, 
                                   const QMap<QString, QJsonValue> &defines)
{
    QString valueString = value.toString();
    if (defines.contains(valueString)) {
        return defines.value(valueString).toString();
    }
    return value.toString();
}

static inline QColor jsonToColor(const QJsonValue &value,
                                 const QMap<QString, QJsonValue> &defines)
{
    QString color = value.toString();
    if (defines.contains(color)) {
        color = defines.value(color).toString();
    }
    
    // We need to skip the warning caused by a null value, 
    // so we check if the color is not empty
    if (!QColor::isValidColor(color) && !color.isEmpty()) {
        qWarning() << "W" << color << "is not a valid color";
        return QColor();
    }
    
    return QColor(color);
}

static inline int jsonToInt(const QJsonValue &value,
                            const QMap<QString, QJsonValue> &defines)
{
    QJsonValue trueValue = value;
    if (value.isString()) {
        QString valueString = value.toString();
        if (defines.contains(valueString)) {
            trueValue = defines.value(valueString);
        }
    }
        
    double doubleValue = trueValue.toDouble();
    return (int) doubleValue;
}

static inline int jsonToDouble(const QJsonValue &value,
                               const QMap<QString, QJsonValue> &defines)
{
    QJsonValue trueValue = value;
    if (value.isString()) {
        QString valueString = value.toString();
        if (defines.contains(valueString)) {
            trueValue = defines.value(valueString);
        }
    }
        
    return trueValue.toDouble();
}

void NemoTheme::loadFromFile(const QString &fileName)
{
    QDir dir (THEME_DIR);
    if (!dir.exists(fileName)) {
        qWarning() << "E" << Q_FUNC_INFO << "Theme file" << fileName << "does not exists.";
        return;
    }

    QFile themeFile (dir.absoluteFilePath(fileName));
    if (!themeFile.open(QIODevice::ReadOnly)) {
        qWarning() << "E" << Q_FUNC_INFO << "Theme file" << fileName << "could not be read.";
        return;
    }

    QJsonParseError error;
    QJsonDocument themeDocument = QJsonDocument::fromJson(themeFile.readAll(), &error);
    themeFile.close();

    if (error.error != QJsonParseError::NoError) {
        qWarning() << "E" << Q_FUNC_INFO << "Cannot parse theme file:" << error.errorString();
        return;
    }

    // Fetch all the defines
    QMap<QString, QJsonValue> defines;
    
    if (!themeDocument.isObject()) {
        qWarning() << "E" << Q_FUNC_INFO << "Theme file has an invalid format";
        return;
    }
    
    QJsonObject themeObject = themeDocument.object();
    
    if (themeObject.contains(THEME_DEFINES_KEY)) {
        QJsonValue definesJson = themeObject.value(THEME_DEFINES_KEY);
        if (!definesJson.isObject()) {
            qWarning() << "W" << Q_FUNC_INFO  << "\"defines\" is not defined as an object";
        } else {
            QJsonObject definesObject = definesJson.toObject();
            foreach (const QString key, definesObject.keys()) {
                defines.insert(key, definesObject.value(key));
            }
        }
        
    } else {
        qWarning() << "W" << Q_FUNC_INFO 
                   << "Theme file does not contain a \"defines\" object. "\
                      "Please add an empty \"defines\" object instead";
    }

    // Set the global values (name, description etc.)
    setName(jsonValue(themeObject, THEME_NAME_KEY).toString());
    setDescription(jsonValue(themeObject, THEME_DESCRIPTION_KEY).toString());

    // Parse the defined objects
    QJsonObject styles = jsonValue(themeObject, THEME_STYLES_KEY).toObject();
    if (styles.isEmpty()) {
        return;
    }
    // Setting properties for button
    QJsonObject stylesButton = styles.value("button").toObject();
    m_button->setBackground(jsonToColor(jsonValue(stylesButton, "background", "button"), defines));
    // Setting properties for text
    QJsonObject stylesButtonText = stylesButton.value("text").toObject();
    m_button->text()->setColor(jsonToColor(jsonValue(stylesButtonText, "color", "text"), defines));
    // Setting properties for font
    QJsonObject stylesButtonTextFont = stylesButtonText.value("font").toObject();
    if (stylesButtonTextFont.contains("pointSize")) {
        m_button->text()->font()->setPointSize(jsonToInt(stylesButtonText.value("font"), defines));
    }
    if (stylesButtonTextFont.contains("weight")) {
        m_button->text()->font()->setWeight(jsonToInt(stylesButtonText.value("font"), defines));
    }
    // Setting properties for pressedGradient
    QJsonObject stylesButtonPressedGradient = stylesButton.value("pressedGradient").toObject();
    m_button->pressedGradient()->setCenterColor(jsonToColor(jsonValue(stylesButtonPressedGradient, "centerColor", "pressedGradient"), defines));
    m_button->pressedGradient()->setEdgeColor(jsonToColor(jsonValue(stylesButtonPressedGradient, "edgeColor", "pressedGradient"), defines));
    if (stylesButtonPressedGradient.contains("width")) {
        m_button->pressedGradient()->setWidth(jsonToInt(stylesButton.value("pressedGradient"), defines));
    }
    if (stylesButtonPressedGradient.contains("height")) {
        m_button->pressedGradient()->setHeight(jsonToInt(stylesButton.value("pressedGradient"), defines));
    }
    if (stylesButtonPressedGradient.contains("center")) {
        m_button->pressedGradient()->setCenter(jsonToDouble(stylesButton.value("pressedGradient"), defines));
    }
    if (stylesButtonPressedGradient.contains("edge")) {
        m_button->pressedGradient()->setEdge(jsonToDouble(stylesButton.value("pressedGradient"), defines));
    }
    // Setting properties for primaryButton
    QJsonObject stylesPrimaryButton = styles.value("primaryButton").toObject();
    m_primaryButton->setBackground(jsonToColor(jsonValue(stylesPrimaryButton, "background", "primaryButton"), defines));
    // Setting properties for text
    QJsonObject stylesPrimaryButtonText = stylesPrimaryButton.value("text").toObject();
    m_primaryButton->text()->setColor(jsonToColor(jsonValue(stylesPrimaryButtonText, "color", "text"), defines));
    // Setting properties for font
    QJsonObject stylesPrimaryButtonTextFont = stylesPrimaryButtonText.value("font").toObject();
    if (stylesPrimaryButtonTextFont.contains("pointSize")) {
        m_primaryButton->text()->font()->setPointSize(jsonToInt(stylesPrimaryButtonText.value("font"), defines));
    }
    if (stylesPrimaryButtonTextFont.contains("weight")) {
        m_primaryButton->text()->font()->setWeight(jsonToInt(stylesPrimaryButtonText.value("font"), defines));
    }
    // Setting properties for pressedGradient
    QJsonObject stylesPrimaryButtonPressedGradient = stylesPrimaryButton.value("pressedGradient").toObject();
    m_primaryButton->pressedGradient()->setCenterColor(jsonToColor(jsonValue(stylesPrimaryButtonPressedGradient, "centerColor", "pressedGradient"), defines));
    m_primaryButton->pressedGradient()->setEdgeColor(jsonToColor(jsonValue(stylesPrimaryButtonPressedGradient, "edgeColor", "pressedGradient"), defines));
    if (stylesPrimaryButtonPressedGradient.contains("width")) {
        m_primaryButton->pressedGradient()->setWidth(jsonToInt(stylesPrimaryButton.value("pressedGradient"), defines));
    }
    if (stylesPrimaryButtonPressedGradient.contains("height")) {
        m_primaryButton->pressedGradient()->setHeight(jsonToInt(stylesPrimaryButton.value("pressedGradient"), defines));
    }
    if (stylesPrimaryButtonPressedGradient.contains("center")) {
        m_primaryButton->pressedGradient()->setCenter(jsonToDouble(stylesPrimaryButton.value("pressedGradient"), defines));
    }
    if (stylesPrimaryButtonPressedGradient.contains("edge")) {
        m_primaryButton->pressedGradient()->setEdge(jsonToDouble(stylesPrimaryButton.value("pressedGradient"), defines));
    }
    // Setting properties for groove
    QJsonObject stylesGroove = styles.value("groove").toObject();
    m_groove->setBackground(jsonToColor(jsonValue(stylesGroove, "background", "groove"), defines));
    m_groove->setForeground(jsonToColor(jsonValue(stylesGroove, "foreground", "groove"), defines));
    // Setting properties for textField
    QJsonObject stylesTextField = styles.value("textField").toObject();
    m_textField->setSelectedTextColor(jsonToColor(jsonValue(stylesTextField, "selectedTextColor", "textField"), defines));
    m_textField->setSelectionColor(jsonToColor(jsonValue(stylesTextField, "selectionColor", "textField"), defines));
    // Setting properties for toolBar
    QJsonObject stylesToolBar = styles.value("toolBar").toObject();
    m_toolBar->setBackground(jsonToColor(jsonValue(stylesToolBar, "background", "toolBar"), defines));
    // Setting properties for window
    QJsonObject stylesWindow = styles.value("window").toObject();
    m_window->setBackground(jsonToColor(jsonValue(stylesWindow, "background", "window"), defines));
    // Setting properties for page
    QJsonObject stylesPage = styles.value("page").toObject();
    m_page->setBackground(jsonToColor(jsonValue(stylesPage, "background", "page"), defines));
    // Setting properties for dimmer
    QJsonObject stylesPageDimmer = stylesPage.value("dimmer").toObject();
    m_page->dimmer()->setStartColor(jsonToColor(jsonValue(stylesPageDimmer, "startColor", "dimmer"), defines));
    m_page->dimmer()->setEndColor(jsonToColor(jsonValue(stylesPageDimmer, "endColor", "dimmer"), defines));
    if (stylesPageDimmer.contains("height")) {
        m_page->dimmer()->setHeight(jsonToInt(stylesPage.value("dimmer"), defines));
    }
    if (stylesPageDimmer.contains("startPosition")) {
        m_page->dimmer()->setStartPosition(jsonToDouble(stylesPage.value("dimmer"), defines));
    }
    if (stylesPageDimmer.contains("endPosition")) {
        m_page->dimmer()->setEndPosition(jsonToDouble(stylesPage.value("dimmer"), defines));
    }
    // Setting properties for spinner
    QJsonObject stylesSpinner = styles.value("spinner").toObject();
    if (stylesSpinner.contains("radius")) {
        m_spinner->setRadius(jsonToInt(styles.value("spinner"), defines));
    }
    m_spinner->setPrimaryColor(jsonToColor(jsonValue(stylesSpinner, "primaryColor", "spinner"), defines));
    m_spinner->setSecondaryColor(jsonToColor(jsonValue(stylesSpinner, "secondaryColor", "spinner"), defines));
    if (stylesSpinner.contains("horizontalSpacing")) {
        m_spinner->setHorizontalSpacing(jsonToInt(styles.value("spinner"), defines));
    }
    if (stylesSpinner.contains("verticalSpacing")) {
        m_spinner->setVerticalSpacing(jsonToInt(styles.value("spinner"), defines));
    }
    if (stylesSpinner.contains("initialStateDuration")) {
        m_spinner->setInitialStateDuration(jsonToInt(styles.value("spinner"), defines));
    }
    if (stylesSpinner.contains("transitionDuration")) {
        m_spinner->setTransitionDuration(jsonToInt(styles.value("spinner"), defines));
    }
    // Setting properties for label
    QJsonObject stylesLabel = styles.value("label").toObject();
    if (stylesLabel.contains("color")) {
        m_label->setColor(jsonToColor(styles.value("label"), defines));
    }
    // Setting properties for checkbox
    QJsonObject stylesCheckbox = styles.value("checkbox").toObject();
    m_checkbox->setBack1(jsonToColor(jsonValue(stylesCheckbox, "back1", "checkbox"), defines));
    m_checkbox->setBack2(jsonToColor(jsonValue(stylesCheckbox, "back2", "checkbox"), defines));
}
